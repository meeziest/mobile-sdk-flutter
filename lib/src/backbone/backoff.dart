import 'dart:math';/// Class to handle exponential backoff with jitter for retry attempts.class Backoff {  /// Maximum number of retry attempts allowed.  final int maxAttempts;  /// Base delay in seconds before the first retry attempt.  final int baseDelay;  /// Maximum delay in seconds between retry attempts.  final int maxDelay;  /// Current attempt count.  int attempt = 0;  /// Random number generator for adding jitter to the delay.  final Random _random = Random();  /// Constructs a [Backoff] instance with the specified parameters.  ///  /// [maxAttempts] The maximum number of retry attempts.  /// [baseDelay] The base delay in seconds before the first retry attempt (default is 1).  /// [maxDelay] The maximum delay in seconds between retry attempts (default is 32).  Backoff({    required this.maxAttempts,    this.baseDelay = 1,    this.maxDelay = 32,  });  /// Calculates the next delay duration with exponential backoff and jitter.  ///  /// The delay is calculated as `baseDelay * 2^attempt * (random value between 1 and 2)`,  /// but it is capped at [maxDelay] seconds.  ///  /// Returns a [Duration] representing the delay before the next retry attempt.  Duration nextDelay() {    final delay =        min(baseDelay * pow(2, attempt) * (_random.nextDouble() + 1), maxDelay);    return Duration(seconds: delay.toInt());  }  /// Determines if another retry attempt should be made.  ///  /// Returns `true` if the current attempt count is less than [maxAttempts], otherwise `false`.  bool shouldRetry() {    return attempt < maxAttempts;  }  /// Resets the attempt count to zero.  ///  /// This method should be called when the operation is successful to reset the backoff state.  void reset() {    attempt = 0;  }  /// Increments the attempt count by one.  ///  /// This method should be called after each retry attempt to update the state.  void increment() {    attempt++;  }}